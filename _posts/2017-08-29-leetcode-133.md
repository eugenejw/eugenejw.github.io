---
layout: post
comments: true
description: Using BFS and DFS traversal to clone an undirected graph.
date: 2017-08-29 19:41:00
title: Clone Graph
category: Coding
tags: [Algorithm, DFS, Graph, Leetcode, Medium, Java]
---

**Description**
[133 Clone Graph](https://leetcode.com/problems/clone-graph/description/)
Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.


OJ's undirected graph serialization:
Nodes are labeled uniquely.

We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
As an example, consider the 
```java
serialized graph {0,1,2#1,2#2,2}
```

The graph has a total of three nodes, and therefore contains three parts as separated by #.

First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
Second node is labeled as 1. Connect node 1 to node 2.
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
Visually, the graph looks like the following:
```java
       1
      / \
     /   \
    0 --- 2
         / \
         \_/
```
## BFS Solution

```python
"""
Definition for a undirected graph node
class UndirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
"""
from collections import deque
class Solution:
    """
    @param: node: A undirected graph node
    @return: A undirected graph node
    """
    def cloneGraph(self, node):
        # write your code here
        if not node:
            return None
            
        newNodes = self.getClonedNodes(node)
        
        return newNodes[node.label]
            
    def getClonedNodes(self, node):
        """Clone all nodes in given graph
        """
        cloned = dict()
        queue = deque()
        queue.append(node)
        
        while len(queue) != 0:
            curNode = queue.popleft()
            if curNode.label in cloned:
                newNode = cloned.get(curNode.label)
            else:
                newNode = UndirectedGraphNode(curNode.label)
                cloned[curNode.label] = newNode
            for neighbor in curNode.neighbors:
                if neighbor.label in cloned:
                    newNode.neighbors.append(cloned.get(neighbor.label))
                else:
                    newNeighbor = UndirectedGraphNode(neighbor.label)
                    cloned[neighbor.label] = newNeighbor
                    newNode.neighbors.append(newNeighbor)
                    queue.append(neighbor)
                    
        return cloned        
```

## DFS Solution
Starting from any given node from the original graph, using DFS to traverse the whole graph.
Note that we only create new node when this node is not visited on the original graph, and before returning the node created, we will fully explore its neibours by recursively calling DFS.
If it has been previously visited, we can be sure that we have copied it already, so we do not proceed the recursion, but just return the already created node.


```java
/**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     List<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */
public class Solution {
    
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        /**
        * @timeComplexity: O(n)
        * @algorithm:      DFS
        */
        if (node==null) return null;
        Map<Integer, UndirectedGraphNode> visited = new HashMap<Integer, UndirectedGraphNode>();
        return dfs(node, visited);
    }
    
    private UndirectedGraphNode dfs(UndirectedGraphNode node, Map<Integer, UndirectedGraphNode> visited) {
        if (visited.containsKey(node.label)) {
            return visited.get(node.label);
        }
        UndirectedGraphNode root = new UndirectedGraphNode(node.label);
        visited.put(root.label, root);
        for (UndirectedGraphNode n : node.neighbors) {
            root.neighbors.add(dfs(n, visited));
        }
        return root;
    }
}
```

![img]({{ site.baseurl | prepend:site.url}}/images/133_java.jpg){: .center-image }*Runtime: 5ms*


